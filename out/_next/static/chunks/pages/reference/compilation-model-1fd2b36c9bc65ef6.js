(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[24],{2398:function(e,n,i){(window.__NEXT_P=window.__NEXT_P||[]).push(["/reference/compilation-model",function(){return i(5943)}])},5943:function(e,n,i){"use strict";i.r(n),i.d(n,{__toc:function(){return c}});var t=i(5893),a=i(2673),s=i(3393),r=i(8426);i(9128);var o=i(2643);let c=[{depth:2,value:"Strictly Additive",id:"strictly-additive"},{depth:2,value:"Nintendo-Like",id:"nintendo-like"},{depth:3,value:"0. Build the parser binary",id:"0-build-the-parser-binary"},{depth:3,value:"1. Run the parser binary",id:"1-run-the-parser-binary"},{depth:3,value:"2. Codegen",id:"2-codegen"},{depth:3,value:"3. Chassis Compilation",id:"3-chassis-compilation"},{depth:3,value:"4. Run or Finish",id:"4-run-or-finish"}];function _createMdxContent(e){let n=Object.assign({h1:"h1",h2:"h2",p:"p",ul:"ul",li:"li",code:"code",em:"em",strong:"strong",div:"div",br:"br",a:"a",img:"img",h3:"h3"},(0,o.a)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{children:"Compilation Model"}),"\n",(0,t.jsx)(n.h2,{id:"strictly-additive",children:"Strictly Additive"}),"\n",(0,t.jsx)(n.p,{children:'A core technical constraint of Pax is that it is "strictly additive" to existing Rust code.'}),"\n",(0,t.jsx)(n.p,{children:"Pax should never get in the way of compiling your Rust program.  For example, the following should work out of the box:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Cargo commands like ",(0,t.jsx)(n.code,{children:"cargo test"})]}),"\n",(0,t.jsx)(n.li,{children:"vanilla CI/CD workflows for Rust"}),"\n",(0,t.jsx)(n.li,{children:"Cargo crates, imports & exports"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Pax ",(0,t.jsx)(n.em,{children:"does"})," create different kinds of executables than ",(0,t.jsx)(n.code,{children:"rustc"}),", however:  Pax outputs ",(0,t.jsx)(n.em,{children:"application binaries"}),", for example ",(0,t.jsx)(n.code,{children:".exe"})," apps for Windows and ",(0,t.jsx)(n.code,{children:".app"})," for macOS.  While you can still create vanilla Rust executables with a Pax-connected codebase (with ",(0,t.jsx)(n.code,{children:"rustc"}),"), you can ",(0,t.jsx)(n.em,{children:"additionally"})," create app executables (with ",(0,t.jsx)(n.code,{children:"pax"}),")."]}),"\n",(0,t.jsxs)(n.p,{children:["What do the ",(0,t.jsx)(n.code,{children:"pax"})," macros add to a codebase?  Namely: feature-gated parsing logic & metadata so that the Pax compiler can make sense of ",(0,t.jsx)(n.em,{children:"where"})," to attach itself and ",(0,t.jsx)(n.em,{children:"what"})," data to compile."]}),"\n",(0,t.jsx)(n.h2,{id:"nintendo-like",children:"Nintendo-Like"}),"\n",(0,t.jsx)(n.p,{children:"Pax's compilation model is inspired by the Nintendo Entertainment System.  For illustration, let's divide the Nintendo into four functional parts:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Television (output)"}),"\n",(0,t.jsx)(n.li,{children:"Controller (input)"}),"\n",(0,t.jsx)(n.li,{children:"Console"}),"\n",(0,t.jsx)(n.li,{children:"Cartridge"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["The NES did not have an operating system, ",(0,t.jsx)(n.em,{children:"per se"})," —\xa0the console was half of a circuit, awaiting the cartridge to be inserted and complete that circuit.  Once connected and powered on, the four pieces together represent a single ",(0,t.jsx)(n.em,{children:"application"})," (in the NES's case, a game), similar to opening a .exe on Windows or a .apk on Android today."]}),"\n",(0,t.jsx)(n.p,{children:"Now consider Pax through the lens of those four pieces:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Screen & audio / Output"})," — in Pax, rendering to the screen happens through a native rendering context, e.g. CoreGraphics on macOS and iOS, Direct2D on Windows, and Canvas2D in the browser."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Controller / Input"})," — In Pax, native events like touch and click are handled by the runtime, similarly to pressing controller buttons on the NES.  A platform-specific ",(0,t.jsx)(n.code,{children:"chassis"})," (see next) is in charge of translating native OS events into Pax's common event model."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Console"})," — Imagine that instead of a single Nintendo Entertainment System, there were six different kinds of NES, for six different kinds of alien televisions and six different kinds of alien controllers.  Despite the alien nature of the various consoles, however, there's a shared cartridge format, which plugs into each of them.  These alien consoles are roughly the idea of platform-specific ",(0,t.jsx)(n.code,{children:"chassis"})," in Pax (so-called because ",(0,t.jsx)(n.code,{children:"console"})," already has specific meaning to developers.)  Like the Nintendo itself, these ",(0,t.jsx)(n.code,{children:"chassis"})," act as the process entry-point for a given platform."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Cartridge"}),' — The cartridge contains compiled userland Pax code, as machine-code.  Anything written in Pax — templates, settings, expressions — get transpiled to Rust, in a specific format internally termed "RIL" or "Rust Intermediate Language".  That "cartridge definition" in RIL, akin to the integrated circuits of ROM and RAM in a Nintendo cartridge, gets compiled into platform-agnostic machine code, with an interface around the idea of "some user input" and "some rendering output."  That slug of machine code — again, the ',(0,t.jsx)(n.code,{children:"cartridge"})," — gets imported as a dependency by the relevant platform ",(0,t.jsx)(n.code,{children:"chassis"})," and compiled together into the final executable."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Noteworthy about this approach is its ",(0,t.jsx)(n.em,{children:"inversion of dependencies"}),".  When you write a Pax program, you write a ",(0,t.jsx)(n.code,{children:"library"})," rather than a ",(0,t.jsx)(n.code,{children:"binary"}),".  The Pax compiler is in charge of wrapping your ",(0,t.jsx)(n.code,{children:"library"})," into the containing ",(0,t.jsx)(n.code,{children:"binary"})," for distribution, like plugging a cartridge into a console, then packaging the duo as a native software application."]}),"\n",(0,t.jsxs)(n.div,{style:{textAlign:"center",fontStyle:"italic",fontWeight:"100"},children:["\n    ",(0,t.jsx)(n.br,{}),"\n    ",(0,t.jsx)(n.a,{href:"./runtime-arch.png",target:"_blank",children:(0,t.jsx)(n.img,{style:{width:"100%",border:"10px solid rgb(0,0,0)"},src:"../images/runtime-arch.png"})}),"\n    ",(0,t.jsx)(n.br,{}),'\n    Diagram of Pax\'s runtime dependency graph, illustrating the "Nintendo" model\n    ',(0,t.jsx)(n.br,{}),"\n    ",(0,t.jsx)(n.br,{}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["When you write a Pax program, you are authoring a ",(0,t.jsx)(n.code,{children:"cartridge"}),", like an NES game.  When you compile a Pax program, the Pax compiler takes care of plugging that ",(0,t.jsx)(n.code,{children:"cartridge"})," into a platform-specific ",(0,t.jsx)(n.code,{children:"chassis"}),", compiling the whole thing, and producing a syndication-ready executable for the target platform, like an .exe for Windows or a .apk for Android."]}),"\n",(0,t.jsxs)(n.p,{children:["At runtime, the ",(0,t.jsx)(n.code,{children:"chassis"})," maps user inputs into Pax events, and maps Pax rendering commands to an operating system-native drawing context."]}),"\n",(0,t.jsx)(n.h1,{children:"Compiler Sequence"}),"\n",(0,t.jsxs)(n.div,{style:{textAlign:"center",fontStyle:"italic",fontWeight:"100"},children:["\n    ",(0,t.jsx)(n.br,{}),"\n    ",(0,t.jsx)(n.a,{href:"./compiler-sequence.png",target:"_blank",children:(0,t.jsx)(n.img,{style:{width:"100%",border:"10px solid #C1272D"},src:"../images/compiler-sequence.png"})}),"\n    ",(0,t.jsx)(n.br,{}),"\n    Sequence diagram for the Pax compiler\n    ",(0,t.jsx)(n.br,{}),"\n    ",(0,t.jsx)(n.br,{}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["When you run ",(0,t.jsx)(n.code,{children:"pax build"})," or ",(0,t.jsx)(n.code,{children:"pax run"}),", the following sequence occurs:"]}),"\n",(0,t.jsx)(n.h3,{id:"0-build-the-parser-binary",children:"0. Build the parser binary"}),"\n",(0,t.jsxs)(n.p,{children:["Any Pax project can be compiled into a special bin target called ",(0,t.jsx)(n.code,{children:"parser"}),".  Pax relies on building and executing this ",(0,t.jsx)(n.code,{children:"parser"})," independently of your actual program, and it is through this special binary that Pax executes dynamic evaluation of Rust logic to finish parsing.  The parsing code is generated as part of the ",(0,t.jsx)(n.code,{children:"pax"})," macros."]}),"\n",(0,t.jsx)(n.p,{children:"Roughly, when the parser binary is run, it:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Looks for a root/main component definition (via ",(0,t.jsx)(n.code,{children:"#[root]"})," underneath a ",(0,t.jsx)(n.code,{children:"#[derive(Pax)]"}),")"]}),"\n",(0,t.jsx)(n.li,{children:"For each of those roots, parses the template and discovers which dependencies are invoked, and parses properties to resolve names, types, and import paths"}),"\n",(0,t.jsxs)(n.li,{children:["Code-gens recursive calls into Component dependencies' ",(0,t.jsx)(n.code,{children:"parse_to_manifest"})," methods"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:['Primarily, this approach solves the problem of "coordinating between macros," given that ',(0,t.jsx)(n.code,{children:"rustc"})," makes no promises about when macros will be evaluated, and in practice evaluates macros seldom.  This model assures that ",(0,t.jsx)(n.code,{children:"parse_to_manifest"})," always exists and is always as up-to-date as its attached Pax + Rust definitions."]}),"\n",(0,t.jsx)(n.h3,{id:"1-run-the-parser-binary",children:"1. Run the parser binary"}),"\n",(0,t.jsxs)(n.p,{children:["After generating the ",(0,t.jsx)(n.code,{children:"parse_to_manifest"})," logic during the compilation of the parser binary (above,) the Pax compiler calls the resulting executable, which gathers all the parsed information of a Pax program, packs that data into a ",(0,t.jsx)(n.code,{children:"PaxManifest"}),", then serializes and passes that manifest back to the Pax compiler."]}),"\n",(0,t.jsxs)(n.p,{children:["This ",(0,t.jsx)(n.code,{children:"PaxManifest"})," represents the entire definition of the program, in a simple data structure.  Once the ",(0,t.jsx)(n.code,{children:"PaxManifest"})," is populated, the parsing work is done."]}),"\n",(0,t.jsx)(n.h3,{id:"2-codegen",children:"2. Codegen"}),"\n",(0,t.jsxs)(n.p,{children:["From the ",(0,t.jsx)(n.code,{children:"PaxManifest"}),' obtained by parsing, Pax generates "Rust Intermediate Language", i.e. just plain Rust in a specific configuration for the purposes of the Pax runtimes.  Some components of RIL:']}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"PropertiesCoproduct"})," — data structure representing the disjoint union of all component property types, used by runtime to enable polymorphic management of Components and their Properties,"]}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"TypesCoproduct"})," —\xa0data strucure representing the disjoint union of all Property types, used by the runtime to enable polymorphic management of expression vtable entries, expression parameters, and expression return types"]}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"cartridge definition"})," — two major components:\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"a vtable containing every compiled Expression and"}),"\n",(0,t.jsxs)(n.li,{children:["instance factories for components & primitives, invoked recursively underneath ",(0,t.jsx)(n.code,{children:"get_main_component_instance"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"3-chassis-compilation",children:"3. Chassis Compilation"}),"\n",(0,t.jsx)(n.p,{children:'Recall the "inversion of dependencies" described earlier in this chapter.  The final executable for a given platform is the whole "NES Console", but we have only been building the "Cartridge" thus far.'}),"\n",(0,t.jsxs)(n.p,{children:["Now it's time to put the cartridge into the console — which means we must involve a different compiler.  For example, to build for macOS, ",(0,t.jsx)(n.code,{children:"xcode"})," is invoked to build the Swift + C ",(0,t.jsx)(n.code,{children:"dev harness"})," which embeds the macOS ",(0,t.jsx)(n.code,{children:"chassis"}),", which in turn embeds the dynamic ",(0,t.jsx)(n.code,{children:"cartridge"})," built by Pax."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"dev harness"})," is a nearly empty macOS app, built in Swift and Xcode, intended for developing Pax.  The harness + the chassis is collectively our metaphorical console.  Not yet built at the time of this authoring is a ",(0,t.jsx)(n.code,{children:"production harness"}),", which is a separate macOS app (or configuration of the same macOS app) tuned for production builds."]}),"\n",(0,t.jsxs)(n.p,{children:["To pass the compiled, code-genned ",(0,t.jsx)(n.code,{children:"cartridge"})," into this compilation chain, the Pax compiler uses the Cargo ",(0,t.jsx)(n.code,{children:"patch"}),' directive.  This swaps the "placeholder" definitions, the basic stubs included on GitHub for ',(0,t.jsx)(n.code,{children:"pax-cartridge"})," and ",(0,t.jsx)(n.code,{children:"pax-properties-coproduct"}),", for example, out for the new, freshly generated ",(0,t.jsx)(n.code,{children:"cartridge"})," content."]}),"\n",(0,t.jsx)(n.p,{children:"Now, when compiled through Xcode (for our macOS example,) we have a complete, native executable."}),"\n",(0,t.jsx)(n.h3,{id:"4-run-or-finish",children:"4. Run or Finish"}),"\n",(0,t.jsxs)(n.p,{children:["Depending on whether you tasked the compiler with ",(0,t.jsx)(n.code,{children:"run"})," or ",(0,t.jsx)(n.code,{children:"build"}),", the compiler will either run the resulting executable immediately, or write the executable to disk in the specified directory"]})]})}let d={MDXContent:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,o.a)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(_createMdxContent,{...e})}):_createMdxContent(e)},pageOpts:{filePath:"pages/reference/compilation-model.md",route:"/reference/compilation-model",pageMap:[{kind:"Meta",data:{index:"Introduction","intro-priorities-and-prior-art":"Priorities and Prior Art",installation:"Installation","key-concepts":"Key Concepts",examples:"Examples",reference:"Reference","authors-contributors":"Contributors",contact:{title:"Contact ↗",type:"page",href:"https://x.com/DevelopingPax",newWindow:!0}}},{kind:"MdxPage",name:"authors-contributors",route:"/authors-contributors"},{kind:"MdxPage",name:"examples",route:"/examples"},{kind:"MdxPage",name:"index",route:"/"},{kind:"Folder",name:"installation",route:"/installation",children:[{kind:"Meta",data:{"operating-systems":"Operating Systems","app-targets":"Application Targets",plugins:"Plugins"}},{kind:"Folder",name:"app-targets",route:"/installation/app-targets",children:[{kind:"Meta",data:{web:"Web",desktop:"Desktop (MacOS)",mobile:"Mobile (iOS)"}},{kind:"MdxPage",name:"desktop",route:"/installation/app-targets/desktop"},{kind:"MdxPage",name:"mobile",route:"/installation/app-targets/mobile"},{kind:"MdxPage",name:"web",route:"/installation/app-targets/web"}]},{kind:"Folder",name:"operating-systems",route:"/installation/operating-systems",children:[{kind:"Meta",data:{macos:"MacOS",linux:"Linux",windows:"Windows"}},{kind:"MdxPage",name:"linux",route:"/installation/operating-systems/linux"},{kind:"MdxPage",name:"macos",route:"/installation/operating-systems/macos"},{kind:"MdxPage",name:"windows",route:"/installation/operating-systems/windows"}]},{kind:"MdxPage",name:"plugins",route:"/installation/plugins"}]},{kind:"MdxPage",name:"intro-priorities-and-prior-art",route:"/intro-priorities-and-prior-art"},{kind:"Folder",name:"key-concepts",route:"/key-concepts",children:[{kind:"Meta",data:{components:"Components",templates:"Templates",settings:"Settings",expressions:"Expressions",handlers:"Handlers",primitives:"Primitives"}},{kind:"MdxPage",name:"components",route:"/key-concepts/components"},{kind:"MdxPage",name:"expressions",route:"/key-concepts/expressions"},{kind:"MdxPage",name:"handlers",route:"/key-concepts/handlers"},{kind:"MdxPage",name:"primitives",route:"/key-concepts/primitives"},{kind:"MdxPage",name:"settings",route:"/key-concepts/settings"},{kind:"MdxPage",name:"templates",route:"/key-concepts/templates"}]},{kind:"Folder",name:"reference",route:"/reference",children:[{kind:"Meta",data:{designability:"Designability",layout:"Layout & Transforms","pax-std":"Pax Std",paxel:"Paxel","compilation-model":"Compilation Model",macros:"Macros","hardware-component-model":"Hardware Component Model","native-rendering":"Native Rendering",grammar:"DSL Grammar",javascript:"Pax & Javascript"}},{kind:"MdxPage",name:"compilation-model",route:"/reference/compilation-model"},{kind:"MdxPage",name:"designability",route:"/reference/designability"},{kind:"MdxPage",name:"grammar",route:"/reference/grammar"},{kind:"MdxPage",name:"hardware-component-model",route:"/reference/hardware-component-model"},{kind:"MdxPage",name:"javascript",route:"/reference/javascript"},{kind:"MdxPage",name:"layout",route:"/reference/layout"},{kind:"MdxPage",name:"macros",route:"/reference/macros"},{kind:"MdxPage",name:"native-rendering",route:"/reference/native-rendering"},{kind:"MdxPage",name:"pax-std",route:"/reference/pax-std"},{kind:"MdxPage",name:"paxel",route:"/reference/paxel"}]}],flexsearch:{codeblocks:!0},title:"Compilation Model",headings:c},pageNextRoute:"/reference/compilation-model",nextraLayout:s.ZP,themeConfig:r.Z};n.default=(0,a.j)(d)},8426:function(e,n,i){"use strict";var t=i(5893),a=i(5379),s=i.n(a);i(7294);let r={logo:e=>{let{darkMode:n}=e;return(0,t.jsxs)("svg",{height:"30",viewBox:"0 0 297 150",fill:"none",xmlns:"http://www.w3.org/2000/svg",className:"jsx-37c7cf7a4c4dcf24",children:[(0,t.jsxs)("g",{clipPath:"url(#clip0_100_305)",className:"jsx-37c7cf7a4c4dcf24",children:[(0,t.jsx)("path",{d:"M62.8831 75.0046C72.2158 75.0046 80.687 66.4399 80.687 57.0042C80.687 47.5686 72.2158 39.0039 62.8831 39.0039C53.5504 39.0039 45.0792 47.5686 45.0792 57.0042C45.0792 66.4399 53.5504 75.0046 62.8831 75.0046Z",fill:"currentColor",className:"jsx-37c7cf7a4c4dcf24"}),(0,t.jsx)("path",{d:"M0 8.42178V139.807L22.8643 149.814V149.737L22.8562 149.743V97.5579V53.8939L22.8643 15.7005L45.6553 7.85025L22.8643 0L0 8.42178Z",fill:"currentColor",className:"jsx-37c7cf7a4c4dcf24"}),(0,t.jsx)("path",{d:"M262.765 7.85022H45.6526V25.6033C45.6037 25.6445 45.5547 25.6829 45.5085 25.7242C50.6994 21.3306 57.4802 18.624 63.5652 18.624C79.8119 18.624 96.1889 33.0936 99.1187 51.2533C101.915 32.7336 118.553 18.5031 137.599 18.5031C143.817 18.5031 149.739 20.9733 154.862 24.9933V18.5031H176.468V95.4999H154.862V88.5316C150.378 92.7109 143.817 95.0218 137.599 95.0218C118.667 95.0218 102.116 80.9644 99.1676 62.6124C96.4879 80.7089 81.0511 94.5904 62.4047 94.5904C56.3795 94.5904 50.3733 92.5323 45.6499 88.3256V105.342H262.762L296.997 56.6938L262.762 7.85022H262.765ZM254.872 95.1866H230.168L216.09 74.3314L200.835 95.1866H176.523L203.969 57.0839L177.428 18.3383H201.925L216.397 39.504L230.244 18.3383H254.872L228.374 57.0839L254.872 95.1866Z",fill:"currentColor",className:"jsx-37c7cf7a4c4dcf24"}),(0,t.jsx)("path",{d:"M155.389 56.7653C155.389 47.1262 146.755 38.3967 137.221 38.3967C127.688 38.3967 119.053 47.1262 119.053 56.7653C119.053 66.4043 127.688 75.1338 137.221 75.1338C146.755 75.1338 155.389 66.4043 155.389 56.7653Z",fill:"currentColor",className:"jsx-37c7cf7a4c4dcf24"})]}),(0,t.jsx)("defs",{className:"jsx-37c7cf7a4c4dcf24",children:(0,t.jsx)("clipPath",{id:"clip0_100_305",className:"jsx-37c7cf7a4c4dcf24",children:(0,t.jsx)("rect",{width:"297",height:"149.814",fill:"white",className:"jsx-37c7cf7a4c4dcf24"})})}),(0,t.jsx)(s(),{id:"37c7cf7a4c4dcf24",children:"svg.jsx-37c7cf7a4c4dcf24{-webkit-mask-image:-webkit-linear-gradient(30deg,black 25%,rgba(0,0,0,.2)50%,black 75%);mask-image:-webkit-linear-gradient(30deg,black 25%,rgba(0,0,0,.2)50%,black 75%);mask-image:-moz-linear-gradient(30deg,black 25%,rgba(0,0,0,.2)50%,black 75%);mask-image:-o-linear-gradient(30deg,black 25%,rgba(0,0,0,.2)50%,black 75%);mask-image:linear-gradient(60deg,black 25%,rgba(0,0,0,.2)50%,black 75%);-webkit-mask-size:400%;mask-size:400%;-webkit-mask-position:0%;mask-position:0%}svg.jsx-37c7cf7a4c4dcf24:hover{-webkit-mask-position:100%;mask-position:100%;-webkit-transition:mask-position 1s ease,-webkit-mask-position 1s ease;-moz-transition:mask-position 1s ease,-webkit-mask-position 1s ease;-o-transition:mask-position 1s ease,-webkit-mask-position 1s ease;transition:mask-position 1s ease,-webkit-mask-position 1s ease}"})]})},project:{link:"https://github.com/paxengine/pax"},chat:{link:"https://discord.com"},docsRepositoryBase:"https://github.com/paxengine/docs",footer:{text:"Pax Corp Inc."},useNextSeoProps:()=>({titleTemplate:"%s"}),head:(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)("meta",{name:"viewport",content:"width=device-width, initial-scale=1.0"}),(0,t.jsx)("meta",{property:"og:title",content:"Pax Docs"}),(0,t.jsx)("meta",{property:"og:description",content:"Documentation for Pax"}),(0,t.jsx)("link",{rel:"icon",href:"./favicon.svg",type:"image/svg+xml"})]})};n.Z=r},5789:function(){}},function(e){e.O(0,[774,678,888,179],function(){return e(e.s=2398)}),_N_E=e.O()}]);