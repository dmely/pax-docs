{"/examples":{"title":"Examples","data":{"":"We have some examples of pax in the our mono-repo under examples/src.You can run them by going to the root of the repository and running\ncargo run --example EXAMPLE_NAME\nHere is one of the examples (space-game). How high of a score can you get?","controls#Controls:":"Movement: W-A-S-D\nShooting: Spacebar"}},"/":{"title":"Introduction to Pax","data":{"":"Pax is a library for building web & native applications alongside visual creative tools","a-quick-tour#A quick tour":"","how-it-works#How it works":"Pax is made up of two pieces:\nThe interface declaration: .pax file\nThe application logic: .rs file\nThe interface declaration (or template for short) is a declarative way to specify the visual components of the user interface. Pax's templates can be created/edited via our design tool or by hand. See Designability to learn more about how it works.Application logic is written in an accompanying Rust file (or Typescript, coming soon). This logic is triggered via handlers that are specified in templates and can set state that flows into templates.","example#Example":"Writing Pax is intended to feel familiar, and the language borrows many ideas from prior art.Following is a simple Pax component called IncrementMe:\n<Group x=50% y=50% width=120px height=120px @click=self.increment >\n    <Text text={self.num_clicks + \" clicks\"} id=text />\n    <Rectangle\n        fill={rgb(ticks, 75, 150)}\n        corner_radii={RectangleCornerRadii::radii(10.0,10.0,10.0,10.0)}\n    />\n</Group>\n@settings {\n    @pre_render: handle_pre_render,\n    #text {\n        style: {\n                font: {Font::system(\"Times New Roman\", FontStyle::Normal, FontWeight::Bold)},\n                font_size: 22px,\n                fill: WHITE,\n                align_vertical: TextAlignVertical::Center,\n                align_horizontal: TextAlignHorizontal::Center,\n                align_multiline: TextAlignHorizontal::Center\n        }\n    }\n}\nIn this template we define a button that contains text and a rectangle. We use a group to combine them into an entity and attach a click handler to it. The text reads state self.num_clicks and we set the fill (color) of the rectangles using self.ticks as the red parameter of rgb(r,g,b). The last piece to note is the lifecycle handler we enabled in the settings block.Based on this template our application logic must define the state of this component (num_clicks, ticks), the increment function, and the handle_pre_render function.\n//File: lib.rs\n#![allow(unused_imports)]\nuse pax_engine::api::*;\nuse pax_engine::*;\nuse pax_std::components::Stacker;\nuse pax_std::components::*;\nuse pax_std::primitives::*;\nuse pax_std::types::text::*;\nuse pax_std::types::*;\n#[pax]\n#[main]\n#[file(\"lib.pax\")]\npub struct Example {\n    pub ticks: Property<usize>,\n    pub num_clicks: Property<usize>,\n}\nimpl Example {\n    pub fn handle_pre_render(&mut self, ctx: &NodeContext) {\n        let old_ticks = self.ticks.get();\n        self.ticks.set((old_ticks + 1) % 255);\n    }\n    pub fn increment(&mut self, ctx: &NodeContext, args: Event<Click>) {\n        let old_num_clicks = self.num_clicks.get();\n        self.num_clicks.set(old_num_clicks + 1);\n    }\n}\nIn the accompanying rust file, we define the state struct and it's associated functions that we use in the template.Here's the example component running:\nThe above IncrementMe component could be mounted as its own app, or could be composed into other Pax components.We will give a brief introduction to Pax: its goals, how to use it, and details of is design and implementation."}},"/installation/app-targets/desktop":{"title":"Desktop","data":{"":"Currently our only desktop target we support is macOS. We eventually plan to support all 3 major desktop platforms.","build-pax-applications-as-native-macos-apps#Build Pax applications as native macOS apps":"Building macOS apps requires running a Mac with macOS.  This is a constraint enforced technically and legally by Apple.\nInstall xcode >=15.0 and Xcode command line utils: xcode-select --install\nMake sure to accept Xcode's license agreement (prompted during Xcode startup for the first time)\nSDK Version macosx13.3, Xcode version >=15.0\nCurrent Minimum Deployment 13.0\nInstall all necessary build architectures for Rust, so that binaries can be built for both Intel and Apple Silicon macs\nrustup target add aarch64-apple-darwin x86_64-apple-darwin"}},"/installation/app-targets/mobile":{"title":"Mobile","data":{"":"Currently the main mobile target we support is iOS.","build-pax-applications-as-native-ios-apps#Build Pax applications as native iOS apps":"Follow instructions for building native macOS apps, above\nInstall all necessary build architectures for Rust, so that binaries can be built for iOS and simulator targets:\nrustup target add aarch64-apple-ios x86_64-apple-ios aarch64-apple-ios-sim\nInstall ios simulator through Xcode"}},"/installation/app-targets/web":{"title":"Build Pax applications for the Web","data":{"":"Pax applications run on the web via Web Assembly.\nInstall 'wasm-pack' via:\n curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh \nFor Windows, follow instructions to use installer here.\nInstall node v20 LTS, recommended via nvm\n# For macOS / Linux:  first install nvm\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash\nAfter restarting terminal:\nnvm install 20\nnvm use 20 --default\nFor Windows, install nvm-windows and install Node v20 LTS."}},"/installation/operating-systems/linux":{"title":"Linux (Debian / Ubuntu) workstation","data":{"1-install-toolchains#1. Install toolchains":"Get rust (if already installed, ensure rustc version 1.73.0 or higher):\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\nDownload required packages:\napt update && apt install pkg-config libglib2.0-dev libssl-dev libpango1.0-dev\nWeb build requires wasm-pack:\ncargo install wasm-pack","2-install-pax-cli#2. Install pax-cli":"cargo install pax-cli\nNOTE: cargo install pax-cli and first run of pax-cli run might take some time.  Subsequent builds are faster.","3-run#3. Run":"You can either run the examples in the Pax repo (recommended while the project is in Alpha, or you can create a project from scratch.","running-examples-in-the-pax-repo-recommended#Running examples in the Pax repo (recommended)":"Follow the instructions in the GitHub README","creating-a-project-from-scratch#Creating a project from scratch":"Create a new project:\npax-cli new my-first-project\nRun:\ncd my-first-project && pax-cli run --target=web"}},"/installation/operating-systems/macos":{"title":"macOS workstation","data":{"1-install-toolchains#1. Install toolchains":"Get rust (if already installed, ensure rustc version 1.73.0 or higher):\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\nInstall xcode build tools:\nxcode-select --install\nWeb build requires wasm-pack:\ncargo install wasm-pack","2-install-pax-cli#2. Install pax-cli":"cargo install pax-cli\nNOTE: cargo install pax-cli and first run of pax-cli run might take some time.  Subsequent builds are faster.","3-run#3. Run":"You can either run the examples in the Pax repo (recommended while the project is in Alpha, or you can create a project from scratch.","running-examples-in-the-pax-repo-recommended#Running examples in the Pax repo (recommended)":"Follow the instructions in the GitHub README","creating-a-project-from-scratch#Creating a project from scratch":"Create a new project:\npax-cli new my-first-project\nRun:\ncd my-first-project && pax-cli run --target=web"}},"/installation/operating-systems/windows":{"title":"Windows workstation","data":{"1-install-toolchains#1. Install toolchains":"Get rust (if already installed, ensure rustc version 1.73.0 or higher):\nWeb build requires wasm-pack:\ncargo install wasm-pack","2-install-pax-cli#2. Install pax-cli":"cargo install pax-cli\nNOTE: cargo install pax-cli and first run of pax-cli run might take some time.  Subsequent builds are faster.","3-run#3. Run":"You can either run the examples in the Pax repo (recommended while the project is in Alpha, or you can create a project from scratch.","running-examples-in-the-pax-repo-recommended#Running examples in the Pax repo (recommended)":"Follow the instructions in the GitHub README","creating-a-project-from-scratch#Creating a project from scratch":"Create a new project:\npax-cli new my-first-project\nRun:\ncd my-first-project && pax-cli run --target=web"}},"/installation/plugins":{"title":"VSCode and IntelliJ Plugins","data":{"":"We strongly recommend installing a plugin to make Pax easier to learn and write.So far, two code editor plugins are available for Pax --VSCode is our best supported editor, via Pax's implementation of the language server protocol. (see LSP source code and plugin source code)In addition to syntax highlighting, the VSCode plugin includes rich LSP features like go-to-definition and contextual autocomplete.","install-the-vscode-plugin-here#Install the VSCode plugin here":"We've also built a plugin for IntelliJ, which supports syntax highlighting only.  Maintaining the IntelliJ plugin (as of Jan 2024) is not a top priority for us, but\nthe source code is available for anyone who would like to contribute.","install-the-intellij-plugin-here#Install the IntelliJ plugin here":""}},"/key-concepts/components":{"title":"Components","data":{"":"The atomic unit of Pax is a component definition. A component definition for MyNewComponent may look like:\n//File: lib.rs\n#![allow(unused_imports)]\nuse pax_engine::api::*;\nuse pax_engine::*;\nuse pax_std::components::Stacker;\nuse pax_std::components::*;\nuse pax_std::primitives::*;\nuse pax_std::types::text::*;\nuse pax_std::types::*;\n#[pax]\n#[main]\n#[file(\"lib.pax\")]\npub struct Example {\n    pub ticks: Property<usize>,\n    pub num_clicks: Property<usize>,\n}\nimpl Example {\n    pub fn handle_pre_render(&mut self, ctx: &NodeContext) {\n        let old_ticks = self.ticks.get();\n        self.ticks.set((old_ticks + 1) % 255);\n    }\n    pub fn increment(&mut self, ctx: &NodeContext, args: Event<Click>) {\n        let old_num_clicks = self.num_clicks.get();\n        self.num_clicks.set(old_num_clicks + 1);\n    }\n}\n<Group x=50% y=50% width=120px height=120px @click=self.increment >\n    <Text text={self.num_clicks + \" clicks\"} id=text />\n    <Rectangle\n        fill={rgb(ticks, 75, 150)}\n        corner_radii={RectangleCornerRadii::radii(10.0,10.0,10.0,10.0)}\n    />\n</Group>\n@settings {\n    @pre_render: handle_pre_render,\n    #text {\n        style: {\n                font: {Font::system(\"Times New Roman\", FontStyle::Normal, FontWeight::Bold)},\n                font_size: 22px,\n                fill: WHITE,\n                align_vertical: TextAlignVertical::Center,\n                align_horizontal: TextAlignHorizontal::Center,\n                align_multiline: TextAlignHorizontal::Center\n        }\n    }\n}\nYou can think of the component definition as a package for a number of different interconnected pieces.Inside a component definition, there may be:\nA Template\nSettings and Expressions\nProperty Definitions\nEvent Handlers\nA component definition centers around a Rust struct, to which a piece of Pax is attached to through the macro derive(Pax). Pax can either be attached inline using the inlined() attribute or link to a .pax file using the file() attribute using a relative path. For example, the following defines an empty component called EmptyComponent:\nuse pax_lang::api::*;\nuse pax_std::primitives::Group;\n#[derive(Pax)]\n#[inlined(<Group />)] //a one-element template, simply an empty Group\npub struct EmptyComponent {\n    //no properties\n}\nAny component created in Pax can be used inside other components — for example, EmptyComponent can be imported and used in another component's template like:\nuse pax_lang::api::*;\nuse crate::EmptyComponent;\n#[derive(Pax)]\n#[inlined(<EmptyComponent />)] //another one-element template, ultimately still not rendering anything\npub struct StillEmptyComponent {\n    //no properties\n}\nThis \"components all the way down\" pattern may be familiar if you have used a GUI framework like React or Vue.This is essentially how you define a Pax Component. The only exception is the root component which is signified with the main attribute and lives in the root lib.rs.Notice that Pax builds off of Rust's import and namespace resolution mechanisms, so importing crate::EmptyComponent to a .rs file means that you can use <EmptyComponent /> inside a template in that file.You can read more about Pax components in the chapter Hardware Component Model.\nA biological cell with computer chips for organelles"}},"/key-concepts/templates":{"title":"Templates","data":{"":"A component's template describes that component's content and hierarchy.Example template:\n<Group>\n    <Rectangle />\n</Group>\nEach component declares a template in an XML-like syntax, which describes how its UI should be displayed.  A component's template is made up of other components.","control-flow#Control flow":"Templates are not just static -- they allow three kinds of control-flow, affecting the tree structure of the template based on certain data conditions.","if#if":"if allows turning on or off a subtree of a template dynamically, based on a boolean condition.  For example:\nuse pax_lang::api::*;\nuse crate::{DetailsView, SummaryView};\n#[derive(Pax)]\n#[inlined(\n    <Group>\n        if self.should_show_details {\n            <DetailsView />\n        } else {\n            <SummaryView />\n        }\n    </Group>\n)]\npub struct IfExample {\n    pub should_show_details: Property<bool>\n}\nInternally, Pax handles evaluation of the if condition as an Expression, via the primitive Conditional.","for#for":"for allows repeating of template elements dynamically based on data.For example:\nuse pax_lang::api::*;\nuse pax_std::layout::{Stacker, StackerDirection};\nuse crate::DeviceRecord;\n#[derive(Pax)]\n#[inlined(\n    <Stacker>\n        for device_record in self.connected_devices {\n            <Stacker direction=StackerDirection::Vertical cells=3>\n                <Text text={device_record.id}></Text>\n                <Text text={device_record.name}></Text>\n                <Text text={device_record.load_capacity}></Text>\n            </Stacker>\n        }\n    </Stacker>\n)]\npub struct ForExample {\n    pub connected_devices: Property<Vec<DeviceRecord>>\n}\nInternally, Pax handles the for range declaration as an Expression, via the primitive Repeat.","slot#slot":"slot allows a component to defer its content at a certain place in its template.  Specifically, it defers its content to the component's instantiator.For a practical example, consider <Stacker />.  When you use a Stacker, you pass children into it, like:\n//src/slot-example.rs\n#[derive(Pax)]\n#[inlined(\n    <Stacker>\n        <Rectangle id=a />\n        <Rectangle id=b />\n        <Rectangle id=c />\n    </Stacker>\n)]\npub struct SlotExample {}\nWhen Stacker renders, like any component, it will render the elements declared in its template, from /pax-std/.../stacker.rs.  However, the above rectangles are NOT in Stacker's template; they are declared in SlotExample's template in ./slot-example.rs.How do we \"teleport\" these Rectangles from SlotExample's template into Stacker?  The answer is slot.If you pop open the source code for Stacker, you will find that it uses the slot keyword in its template, along with an index specifying \"which indexed child should go in this slot.\"If we were to write a new simplified Stacker that only accepts three children, its template might look like:\n<Frame id=cell_0>\n    slot(0) //the 1st child to an instance of this component will get mounted here\n</Frame>\n<Frame id=cell_1>\n    slot(1) //the 2nd child to an instance of this component will get mounted here\n</Frame>\n<Frame id=cell_2>\n    slot(2) //the 3rd child to an instance of this component will get mounted here\n</Frame>\nBecause slot, like if and repeat, is evaluated as an expression, you can also pass symbol values (expressions) into slots arguments.  This is how the real Stacker accepts i dynamic children via slot, with a template like:\nfor (elem, i) in self.computed_layout_spec {\n    <Frame x={elem.x_px} y={elem.y_px} width={elem.width_px} height={elem.height_px}>\n        slot(i)\n    </Frame>\n}"}},"/reference/grammar":{"title":"Grammar","data":{"":"The Pax language comprises three grammars:\nTemplate grammar\nSettings grammar\nExpressions grammar\nEach grammar serves a specific function:\ntemplates declare content & dynamic branching (if,for)\nsettings assign values to properties, optionally with CSS-like syntax\nexpressions allows binding properties to spreadsheet-like functions of state\nPax's parser is powered by a Parsing Expression Grammar (PEG), using PestRather than maintaining a separate rendition of the grammar here in the docs, refer to the grammar in the source code."}},"/reference/javascript":{"title":"Pax and JavaScript","data":{"":"Recall Pax's model as a \"companion language\" to Rust.  Pax definitions \"snap on\" to a host codebase, allowing that codebase to drive changes in state, respond to user input, perform side effects like network requests, and assemble reusable modules.\n// Pax with a Rust host codebase\n// src/hello-world.rs\nuse pax_lang::*;\nuse pax_lang::std::drawing2D::Rectangle;\n#[pax(\n    //On click, update theta and cause this Rectangle to rotate\n    <Rectangle @click=self.handle_click transform={\n        anchor(50%, 50%)   * \n        translate(50%, 50%)    * \n        rotate(self.theta) \n    } />\n)]\npub struct HelloWorld {\n    theta: Property<f64>,\n}\nimpl HelloWorld {\n    pub fn handle_click(&mut self, args: ArgsClick) {\n        let old_theta = self.theta.get();\n        \n        //instead of an `ease_to` animation, could set value immediately with `self.theta.set(...)`\n        self.theta.ease_to(\n            old_theta + f64::PI() * 3.0, //new value\n            240,                         //duration of transition, frames\n            EasingCurve::OutBack,        //curve to use for interpolation \n        );\n    }\n}\nIn the future, Pax may also support JavaScript, Python, C++, or any number of other host languages.  With Pax TypeScript, the above example might look like:\n// Pax with TypeScript, speculative API\n// !! TypeScript support has not yet been built !!\nimport {pax, EasingCurve} from '@pax-lang/pax';\n@pax(`\n    <Rectangle @click=this.handleClick transform={\n        anchor(50%, 50%) *\n        align(50%, 50%) *\n        rotate(this.theta)\n    } />\n`)\nclass HelloWorld {\n    @property\n    theta: number;\n    \n    handleClick(args: ArgsClick) {\n        const oldTheta = this.theta.get();\n        \n        //instead of an `easeTo` animation, could set value immediately with `self.theta.set(...)`\n        this.theta.easeTo(\n            oldTheta + Math.PI * 3.0,\n            240,\n            EasingCurve.OutBack\n        );\n    }\n}"}},"/reference/layout":{"title":"Coordinate System & Transforms","data":{"":"Pax's coordinate system is \"top-left origin; right is positive x; down is positive y\"","affine-transforms-transform2d#Affine transforms (Transform2D)":"The way elements get positioned, sized, and moved around in Pax is through the powerful transform property.  This property is nearly ubiquitous across the landscape of GUI and graphical development tools (such as matrix3d() in CSS), but it tends to be more front-and-center in game engines than it is in UI layout systems.Perhaps the easiest way to think about Pax's transform model is \"design tool coordinates.\"  That is, when you select an element in a vector design tool like Figma, Sketch, or Illustrator, you can: drag it (translate), resize it (scale), rotate it, and skew it (with a combination of rotation and scale.)  Each of these operations can be expressed in Pax, as well.\n<Group id=a transform=rotate(150deg)>\n    <Rectangle id=b transform=translate(50px, 50px) />\n    <Rectangle id=c transform=scale(150%, 150%) />\n</Group>\nIn the above example, rectangle b will be moved 50px to the right and 50px down.  The rectangle c will be 150% the width & height of its default values.  And the group a will be rotated 150 degrees — which, in fact, ends up rotating both of the rectangles as well.  Read more about this below in combining transformations.","common-properties#Common Properties":"In most cases when you don't need to sequence a bunch of transforms in a specific way, you can set the property directly on the template node.There are a set of 13 properties on every template node.\nid: A unique identifier for an element, used to reference it within scripts or CSS-like stylesheets.\nx: The x-coordinate of the element's anchor point in pixels or percentage relative to its container. Determines the horizontal position.\ny: Similar to x, this sets the y-coordinate of the element's anchor point, determining the vertical position.\nscale_x: Controls the width scaling factor of the element. A value of 1 means no scaling, less than 1 means a reduction, and greater than 1 means an enlargement.\nscale_y: Controls the height scaling factor of the element. Works similarly to scale_x, affecting vertical dimensions.\nskew_x: Applies a horizontal skew transformation to the element, distorting it along the x-axis. The skew angle is specified in degrees.\nskew_y: Applies a vertical skew transformation to the element, distorting it along the y-axis. Like skew_x, the angle is specified in degrees.\nanchor_x: Sets the horizontal part of the element's anchor point, which affects transformations like rotation and scaling. It can be defined in pixels or as a percentage of the element’s width.\nanchor_y: Sets the vertical part of the element's anchor point. Similar to anchor_x, but for the vertical dimension.\nrotate: Specifies the rotation of the element around its anchor point, in degrees. Positive values rotate clockwise, while negative values rotate counterclockwise.\ntransform: A powerful property that allows for a combination of transformations—translate, scale, rotate, and skew—applied in a specific order to the element.\nwidth: Sets the width of the element, either in pixels or as a percentage of the container's width, allowing for responsive design.","anchor--align#Anchor & Align":"Pax's coordinate system has a notion of anchor — letting you set the anchored origin point for transformations.  For example, using anchor you can cause a rectangle to be rotated around its top-left corner, vs. rotated around its center-point.Pax's layout system also allows positions (x and y) to be expressed as pixel values, as percentage values of their container for responsive alignment, or as a combination of multiple pixel / percent values (via PAXEL expressions.)For example, <SomeElement x=50% y=50% /> will position an element's anchor at the center of its container.  <SomeElement x=5px y={50% + 5px}> shows both a literal pixel value for x and a combination of multiple units using PAXEL (50% of container's width, plus an additional 5px).The combination of anchor and align offers powerful, fine-grained positioning, well suited to responsive design for varying screen sizes.","combining-transformations#Combining transformations":"What happens when you want to both resize AND rotate an element?  You must combine transformations.  Depending on your needs, there are two broad ways to combine transformations:","1-hierarchical-composition#1. Hierarchical composition":"When you transform an element that can contain other elements -- such as a <Group>...</Group>, all of its children elements will inherit that transformation as a starting point.  For example:\n<Group id=groo >\n    <Rectangle id=ree />\n</Group>\nIf a transform is applied to the group groo, such as a translation by 50px to the right, all descendants (in this case, the rectangle ree) will also be automatically translated by 50px to the right.  This translation occurs after all of ree's transform logic is calculated, and is handled by Pax's core layout engine.This notion of hierarchical transformation may by familiar if you have used the group functionality of a vector design tool — specifically the behavior of individual grouped elements when you drag, rotate, or resize the whole group.  As an exercise, try making a nest multiple layers deep of groups in a vector design tool, and observe what happens to individual elements and groups when you transform the entire container.","2-matrix-multiplication#2. Matrix multiplication":"Often times, you will want to combine transformations on a single element, without using any sort of nesting.  In these cases, you will want to multiply transforms.  This entails two steps:\nuse an expression ({...}) for the transform value, and\nmultiply different affine operations within that expression\nThe reason multiplication is the combinational operator for transformations stems from linear algebra, where matrix multiplication describes the sequential combination of affine transformation matrices.An example of combining multiple transformations with matrix multiplication:\n<Rectangle width=100px height=200px transform={\n    rotate(100deg) *\n    translate(100px, 100px) *\n    scale(200%, 200%)\n} />\nIn the above, the 100px square will be rotated, then translated (moved), then scaled (resized).A few important notes about matrix multiplication:\nOrder matters — for example translate() * rotate() will generally yield different behavior vs. rotate() * translate().\nYou can combine the same operation multiple times — for example scale() * scale() or rotate() * scale() * rotate()\nSince these multiplications happen in an expression context, you may also use symbolic properties in these expressions — for example rotate(self.base_rotation * self.rotation_multiplier) or scale(self.scale_mult) * rotate(self.active_rotation)\nOrganizationally, you may find that it is useful to combine hierarchical grouping with matrix multiplication in different ways.  You may also make use of helper methods which can return dynamic or pre-computed transformations.  Finally, the use of layout components (such as pax-std's Stacker, or components that you may author yourself) allow abstraction of complex positioning and resizing logic.--[1] Affine transforms:  https://en.wikipedia.org/wiki/Affine_transformation"}},"/reference/macros":{"title":"Pax Macros","data":{"":"Rust macros are the way that information gets exposed from Rust to Pax.\nderive(Pax)\nDeclares a Pax component definition, specifically a non-root component that may be imported and instantiated in other components' templates.\n#[main]\nSpecifies the root component of the application\n#[file(FILENAME)]\nDeclares a Pax component definition by pointing to a separate .pax file instead of requiring an inline declaration\n#[inlined(PAX_TEMPLATE)]\nDeclares a Pax component definition inline in a rust file\n#[custom(Default)]\nOptional. Only needed if you want to implement Default for the struct yourself."}},"/reference/pax-std":{"title":"Pax Standard Library (pax-std)","data":{"":"pax-std includes most of Pax's built-in practical functionality.It also offers a canonical example of creating reusable components and primitives, exporting them through Rust's module system and using Cargo to load them into other Rust + Pax projects.The standard library includes:","core#Core":"<Group /> - Groups its descendents into a single render node, which may be transformed, causing all children to inherit that hierarchical transformation.  Works intuitively like a group in a vector design tool.  Groups do not accept a size.<Frame /> - Exactly like a Group, except requires a size, and introduces a clipping context outside of its rectangular boundaries.  Any element that would be rendered outside of those boundaries gets clipped (hidden from view / non-interactable.)<Image /> - !!unimplemented!! allows embedding and rendering a bitmap or vector image<Scroller /> - !!unimplemented!! like a Frame, except allows scrolling on any of x or y axes.  Scrolling will be handled natively via the chassis, and the Scroller's position will reflect the position of the native scrolling container.<Text /> - allows embedding of text content with basic homogeneous styling.  Text's API may be developed and more primitives may be exposed for more complex use-cases like heterogeneous rich text.","drawing#Drawing":"<Rectangle /> - draws a 2D rectangle with specified Fill and Stroke<Ellipse /> - draws a 2D ellipse with specified Fill and Stroke<Path /> - draws a sequence of bezier/line-segment paths, with specified Fill and Stroke","layout#Layout":"<Stacker /> - lays out elements horizontally or vertically.  Can be nested with other Stackers to create arbitrary rectilinear 2D layouts."}},"/authors-contributors":{"title":"Authors & Contributors","data":{"":"The initial author of Pax was Zack Brown, who designed the language and built the first versions of the compiler and runtimes during an independent research sabbatical from late 2021 to early 2023.Warfa Jibril joined & elevated the effort full-time in early 2023.  Samuel Selleck joined in December 2023.  Pax's full-time development is now funded by a commercial entity, PaxCorp Inc.A list of contributors to the Pax project may be found via the repository on GitHub.","how-to-contribute-to-pax#How to Contribute to Pax":"","join-the-conversation#Join the Conversation":"Pax on Discord\nPax on Reddit\nPax on Twitter","write-code#Write Code":"Find a bug? Fix a bug!\nFind a perf bottleneck? Fix a perf bottleneck!\nHelp write tests!\nCreate examples","create-content#Create Content":"Help write explanatory articles, demo videos, blog posts, anything that helps Pax become more accessible to more people.","share-feedback#Share Feedback":"Do you particularly love or dislike something about Pax?  Are you facing a challenge solving a certain problem with Pax?Any feedback, positive or constructive, is welcome and will help push Pax forward.  Jump on Discord or Reddit with feedback, open an Issue or Pull Request on Github, or reach out by email: contact@pax.dev"}},"/intro-priorities-and-prior-art":{"title":"Pax’s Priorities","data":{"made-for-shipping#Made for Shipping":"Native builds: Pax compiles to pure machine-code native binaries for each target platform.  Pax today includes native runtimes for macOS desktop, iOS mobile, and browsers via WebAssemblyTiny footprint: <100KB network footprint for WASM builds, enabled by our unique native compositor. For native builds we target a <1MB binary footprint.Top-tier performance: 240fps on supporting hardware, achieved in early builds, will be an ongoing priority. GPU rendering has been achieved but requires work for production-readiness (namely: WASM footprint reduction.)Accessibility: Pax supports screen readers on each implemented platform, as well as search engine optimization (SEO) in browsers.  This is enabled by compositing native elements — for example, DOM nodes for the web and SwiftUI elements for macOS/iOS — with virtual canvas drawings, for specific primitives like text and form controls.","learnable--powerful#Learnable & Powerful":"Inspired by JSX — anyone who has used React should find Pax familiar.  The syntax, from the XML base flavor through to curly-brace-wrapped expressions, was designed to echo React.  Nonetheless, by compiling into machine code Pax maintains the power, low overhead, and extensibility of systems programming and the Rust ecosystem.Modular & composable — All Pax components are built around Rust structs and exposed through Rust’s module system, for example across Rust crates.  Pax’s standard library is exposed as components and everything is swappable and extensible.Creatively expressive — Animations, mix & match UI elements with design elements, free-form positioning melded with responsive layoutsMultiple programming languages (future) — today we support only Rust for application logic, but plan to extend this to at least TypeScript/Javascript and likely C++, Go, Python, and .NET.","designable#Designable":"Pax’s 100% declarative user interface description language is readable & writable by machines as well as humans.   The language is designed to encode the union of: anything you might express in a Photoshop file and anything you might build in React.  This includes vector elements, responsive layouts, form controls, and custom, composable components.Pax the language is just data — declarative markup and expressions.  Turing-complete logic is handled by the accompanying source code (e.g. Rust), where Rust functions can be bound to Pax events, e.g. <Button @submit=some_rust_function />, and Pax expressions can refer to Rust struct data like <Rectangle x={self.dynamic_x_value} />Further, Pax’s layout engine renders in “design tool coordinates,” the same coordinate space as a tool like Photoshop or Figma.  You can imagine a visual tool statically opening a Pax codebase, performing visual edits, and persisting those edits as source code — all while offering a Figma-like (or Flash-like) creative experience.We call this principle “designability.”[1]Our team is building a commercial, collaborative visual designer for Pax, so people who don’t write code can build software hand-in-hand with those who do. JOIN THE EARLY ACCESS LIST","verilog-vhdl#Verilog, VHDL":"For highly functional & highly declarative logic, and for designable logic, teaching that it is possible for visual tooling to read & write code that can also be read & written by hand.","macromedia-flash-dreamweaver#Macromedia Flash, Dreamweaver":"For instilling the paradigm of design tools that create software (contrast with: design tools that create pictures.)Flash specifically, for teaching that it is possible to bring a higher level of art to interactive digital media, if we empower artists with the right tools and better-enable collaboration between designers & developers.","the-world-wide-web-html-css#The World Wide Web, HTML, CSS":"For instilling a paradigm of openness, for becoming the substrate of the free exchange of human knowledge, for championing accessibility, for achieving a nearly ubiquitous VM & runtime, for achieving a \"zero-trust\" application runtime, and for establishing a lingua franca of UI authoring + ergonomic expectations.","react-vue-angular#React, Vue, Angular":"For establishing the \"components all the way down\" approach to UI authoring; for bringing this approach to the mainstream, and for helping push the modern Web platform toward its pinnacle form.","flutter-xamarin-unity-qt-electron-and-react-native#Flutter, Xamarin, Unity, Qt, Electron, and React Native":"For their various approaches to cross-platform application runtimes.","visual-basic-aspnet#Visual Basic, ASP.NET":"VB for its visual building approach to GUIs and ASP.NET for championing the \"code-behind\" model, separating concerns of UI content and behavior from application logic, and doing so in a multi-language way.","visicalc-lotus-1-2-3-excel#VisiCalc, Lotus 1-2-3, Excel":"For teaching that writing simple expressions (formulae) is accessible to a huge audience of users, beyond traditional developers.  For fundamentally transforming how humans interact with data & computers.","the-nintendo-entertainment-system#The Nintendo Entertainment System":"For doing so much with so little, for years of childhood wonder, exploration, and reflex honing, and for the model of the \"cartridge + console,\" borrowed architecturally for Pax's compilation model.."}},"/key-concepts/expressions":{"title":"Expressions","data":{"":"<Rectangle transform={\n    rotate(engine.frames_elapsed / 200.0) *\n    translate(in.mouse_x, in.mouse_y)\n}/>\nConsider the above snippet of Pax.  If you're familiar with a templating language like JSX, you might expect that the Expression code within the braces above { ... } is inline Rust code.  In fact, this code has many syntactic similarities with Rust, but it is not Rust.It is PAXEL — part of Pax, a special-purpose language for declaring computed properties in the spirit of spreadsheet formulas.Anytime you write in between {}s in Pax, you are writing PAXEL.  You can create a PAXEL Expression anywhere you can declare a settings value, in template definitions or in @settings blocks.For example the expression self.activeColor.adjustBrightness(50%) might live in a template:\n<Rectangle fill={ self.activeColor.adjustBrightness(50%) } />\nor in a settings block:\n@settings {\n  #my_rectangle {\n    fill: { self.activeColor.adjustBrightness(50%) }\n  }\n}\nPax expressions are ultimately compiled to machine code (WASM or LLVM), and the Pax runtime manages each expression as its own compiled function in a vtable.Because Pax Expressions are pure, side-effect-free functions, the Pax runtime can (one day) make aggressive optimizations: caching values\nand only recomputing when one of the stated inputs changes.  Expressions are also readily parallelizable, a prospective future performance optimization.You can read more about PAXEL, the Pax Expression Language, in this chapter."}},"/key-concepts/handlers":{"title":"Event Handlers","data":{"":"A finger on a touch-screen, emitting lightning where it touches\n#[pax(\n    <Rectangle @click=self.handle_click>\n)]\npub struct HelloEvents {}\nimpl HelloEvents {\n    pub fn handle_click(&mut self, _ctx: &NodeContext, args: Event<Click>) {\n    }\n}\nIn the above example, on_click=self.handle_click binds a the handle_click method defined in the host codebase to the built-in click event which Pax fires when a user clicks the mouse on this element.Events fire as \"interrupts\" and are allowed to execute arbitrary, side-effectful, imperative logic — anything you can write or use in Rust.It is inside event handlers that you will normally change property values, using .set or .ease_to.Pax includes a number of built-in user interaction events like @click and @tap.  These can all be bound and handled in the same manner.There are two types of events in Pax:","lifecycle-events#Lifecycle Events":"Lifecycle events run at the various points of the lifecycle a component.Lifecycle events are registered in a settings block on a Pax Template:\n#[pax(\n    <Rectangle>\n    \n    @settings {\n        @tick: handle_tick\n    }\n)]\npub struct HelloEvents {}\nimpl HelloEvents {\n    pub fn handle_tick(&mut self, _ctx: &NodeContext) {\n    }\n}\nPax exposes three lifecycle events:","tick#Tick":"Tick is a fundamental unit of pax-engine, similar to a clock cycle. If you want a computation to happen every frame, you likely want to put it in the tick method.","mount#Mount":"Mount runs whenever a component is placed in the scene. It should run once per component.","pre-render#Pre-render":"Pre-render runs every frame like tick but right before the component is rendered.","input-events#Input Events":"Input events run when user's interact with the Pax UI.Here's an example of adding click handler to the HelloEvents component:\n#[pax(\n    <Rectangle @click=self.handle_click>\n)]\npub struct HelloEvents {}\nimpl HelloEvents {\n    pub fn handle_click(&mut self, _ctx: &NodeContext, args: Event<Click>) {\n    }\n}\nYou can attach an input event handler to any node in a template with an inline binding (@name_of_event=name_of_function) on the tag. The associated function is implemented in the Component's impl block as seen above. The arguments for all events can be found here.Pax supports the following input events:\nScroll (@scroll)\nClap (@clap)\nTouchStart (@touch_start)\nTouchMove (@touch_move)\nTouchEnd (@touch_end)\nKeyDown (@key_down)\nKeyUp (@key_up)\nKeyPress (@key_press)\nCheckboxChange (@checkbox_change)\nButtonClick (@button_click)\nTextboxChange (@textbox_change)\nTextInput (@text_input)\nTextboxInput (@textbox_input)\nClick (@click)\nMouseDown (@mouse_down)\nMouseUp (@mouse_up)\nMouseMove (@mouse_move)\nMouseOver (@mouse_over)\nMouseOut (@mouse_out)\nDoubleClick (@double_click)\nContextMenu (@context_menu)\nWheel (@wheel)"}},"/key-concepts/primitives":{"title":"Primitives","data":{"":"Primitives are a special case of component — with direct access to the engine, runtime, and rendering context.  Primitives are authored in pure Rust, without any Pax language sugar: templates, expressions, or settings.Most of Pax's included primitives are housed in the standard library, including: <Group />, <Rectangle />, <Frame />, and <Image />.The built-in constructs for control flow, like if (Conditional) and for (Repeat) are implemented as primitives, too, with special handling by the engine.","using--authoring-primitives#Using & Authoring Primitives":"Using primitives is easy.  Any place you can use a component in a template, you can use a primitive instance in exactly the same way.  For example, <Stacker /> is a component, but <Rectangle /> is a primitive.  They are consumed the same way.Authoring primitives is more advanced.  More thorough documentation could be written, but for now refer to pax-std/pax-std-primitives/src/* and pax-std/src/lib.rs.  Primitives are authored in an engine-adjacent context, where certain imports are disallowed to avoid circular dependencies.This complexity is due to Pax's compilation model, where the userland logic is ultimately a dependency of the engine, instead of the other way around.  This is normally papered over when writing normal components and applications — the compiler handles this dependency inversion.One more way to think of the above, through the NES cartridge model: Primitives are authored in the context of the console rather than the context of cartridges.Primitives are exposed cartridge-side (e.g. for importing and using <Group />) through the pax_primitive macro — you can find examples of this in pax-std/src/lib.rs."}},"/key-concepts/settings":{"title":"Properties & Settings","data":{"":"Properties and Settings are two sides of the same idea, so they share a chapter in this book.\nTwo illuminated switchboards: one light, one dark\nRecall that the atomic unit of Pax is the component.  Components pass data to each other through properties and settings.[1]","properties#Properties":"Properties could be summarized as inputs to a component — they are the properties of a component that are exposed to consumers.  For example, Stacker, the layout component, exposes a property direction, which dictates whether Stacker lays out its cells horizontally or vertically.Properties are also used internally within a component as state containers, similar in purpose to state in React.  A component's properties may be referred to by any of that component's expressions like: {self.some_property && self.some_other_property}Properties are defined on Rust structs, such as counter below:\nuse pax_lang::api::*;\n#[derive(Pax)]\n#[inlined(\n    <Text text={counter}></Text>\n)]\npub struct MyComponent {\n    counter: Property<i64>,\n}\nNotice that counter is a member of a Pax-attached Rust struct, with a pax_lang::api::Property<T> wrapper around its type.","settings#Settings":"Settings are declarations of values.  If Properties are inputs to a component, then Settings are outputs.  When composing the definition of a component or program, you set the properties of any element in order to specify behavior or appearance.Building off of the Stacker example above, any component that instantiates a Stacker in its template has the opportunity to apply a setting to Stacker, to set its direction property.Let's use the above component inside a new component, AnotherComponent.\nuse pax_lang::api::*;\nuse crate::MyComponent;\n#[pax(\n    <MyComponent counter={self.num_clicks * 2} />\n)]\npub struct AnotherComponent {\n    num_clicks: Property<i64>,\n}\nIn this example, MyComponent's counter property gets set — the declaration of a value, in this case an expression {self.num_clicks * 2}, is a setting.Settings declarations may either be literal values or expressions.  counter=5 would be another valid setting for the example above.","declarative-settings-syntax#Declarative Settings Syntax":"Settings can be declared with two different syntaxes: inline settings or settings block syntax.  Each syntax has access to the exact same properties, and expressions can be bound in either place.","inline-settings#Inline Settings":"Inline settings are authored inline into a template definition.  You might recognize this syntax as nearly identical to XML attributes.  Example:\n//inside a template definition\n<SomeComponent some_property=\"SomeSetting\" />\nUnlike XML, Pax's inline settings syntax supports values beyond string literals, such as enums, symbolic identifiers, and numeric literals.  Pax inline settings may also be bound to expressions, wrapped in {}, such as:\n//`self.current_width` refers to a property from the attached Rust struct, not shown here.\n<Rectangle width={self.current_width} height={self.current_width * 1.5} />","settings-blocks#Settings blocks":"As an alternative to inline syntax, settings may be authored in a CSS-like syntax, binding a block of settings to an element by id.  For example:\n<Rectangle id=my_rect>\n@settings {\n    #my_rect {\n        fill: rgb(100%, 100%, 0)\n    }\n}\nEvery property that is available inline is also available in the settings block syntax, and settings can be mixed and matches across syntaxes.","settings-precedence#Settings precedence":"When both an inline setting and a setting block apply settings for the same property, the inline setting takes precedence.  This \"cascading\" behavior is inspired by HTML and CSS.  When a property is set at runtime, the latest set value takes precedence.","setting-properties-at-runtime#Setting Properties at Runtime":"For a Property<T>, the following API is exposed to Rust logic at runtime:","set#.set":"Set a property value","ease_to#.ease_to":"Ease a property value over time with an easing curve (generally, for animation)","ease_to_later#.ease_to_later":"Same as ease_to, but enqueues the specified transition to occur after all currently enqueued transitions are completed.[1] The relationship between properties & settings is inspired by digital circuits.."}},"/reference/compilation-model":{"title":"Compilation Model","data":{"strictly-additive#Strictly Additive":"A core technical constraint of Pax is that it is \"strictly additive\" to existing Rust code.Pax should never get in the way of compiling your Rust program.  For example, the following should work out of the box:\nCargo commands like cargo test\nvanilla CI/CD workflows for Rust\nCargo crates, imports & exports\nPax does create different kinds of executables than rustc, however:  Pax outputs application binaries, for example .exe apps for Windows and .app for macOS.  While you can still create vanilla Rust executables with a Pax-connected codebase (with rustc), you can additionally create app executables (with pax).What do the pax macros add to a codebase?  Namely: feature-gated parsing logic & metadata so that the Pax compiler can make sense of where to attach itself and what data to compile.","nintendo-like#Nintendo-Like":"Pax's compilation model is inspired by the Nintendo Entertainment System.  For illustration, let's divide the Nintendo into four functional parts:\nTelevision (output)\nController (input)\nConsole\nCartridge\nThe NES did not have an operating system, per se — the console was half of a circuit, awaiting the cartridge to be inserted and complete that circuit.  Once connected and powered on, the four pieces together represent a single application (in the NES's case, a game), similar to opening a .exe on Windows or a .apk on Android today.Now consider Pax through the lens of those four pieces:\nScreen & audio / Output — in Pax, rendering to the screen happens through a native rendering context, e.g. CoreGraphics on macOS and iOS, Direct2D on Windows, and Canvas2D in the browser.\nController / Input — In Pax, native events like touch and click are handled by the runtime, similarly to pressing controller buttons on the NES.  A platform-specific chassis (see next) is in charge of translating native OS events into Pax's common event model.\nConsole — Imagine that instead of a single Nintendo Entertainment System, there were six different kinds of NES, for six different kinds of alien televisions and six different kinds of alien controllers.  Despite the alien nature of the various consoles, however, there's a shared cartridge format, which plugs into each of them.  These alien consoles are roughly the idea of platform-specific chassis in Pax (so-called because console already has specific meaning to developers.)  Like the Nintendo itself, these chassis act as the process entry-point for a given platform.\nCartridge — The cartridge contains compiled userland Pax code, as machine-code.  Anything written in Pax — templates, settings, expressions — get transpiled to Rust, in a specific format internally termed \"RIL\" or \"Rust Intermediate Language\".  That \"cartridge definition\" in RIL, akin to the integrated circuits of ROM and RAM in a Nintendo cartridge, gets compiled into platform-agnostic machine code, with an interface around the idea of \"some user input\" and \"some rendering output.\"  That slug of machine code — again, the cartridge — gets imported as a dependency by the relevant platform chassis and compiled together into the final executable.\nNoteworthy about this approach is its inversion of dependencies.  When you write a Pax program, you write a library rather than a binary.  The Pax compiler is in charge of wrapping your library into the containing binary for distribution, like plugging a cartridge into a console, then packaging the duo as a native software application.When you write a Pax program, you are authoring a cartridge, like an NES game.  When you compile a Pax program, the Pax compiler takes care of plugging that cartridge into a platform-specific chassis, compiling the whole thing, and producing a syndication-ready executable for the target platform, like an .exe for Windows or a .apk for Android.At runtime, the chassis maps user inputs into Pax events, and maps Pax rendering commands to an operating system-native drawing context.When you run pax build or pax run, the following sequence occurs:","0-build-the-parser-binary#0. Build the parser binary":"Any Pax project can be compiled into a special bin target called parser.  Pax relies on building and executing this parser independently of your actual program, and it is through this special binary that Pax executes dynamic evaluation of Rust logic to finish parsing.  The parsing code is generated as part of the pax macros.Roughly, when the parser binary is run, it:\nLooks for a root/main component definition (via #[root] underneath a #[derive(Pax)])\nFor each of those roots, parses the template and discovers which dependencies are invoked, and parses properties to resolve names, types, and import paths\nCode-gens recursive calls into Component dependencies' parse_to_manifest methods\nPrimarily, this approach solves the problem of \"coordinating between macros,\" given that rustc makes no promises about when macros will be evaluated, and in practice evaluates macros seldom.  This model assures that parse_to_manifest always exists and is always as up-to-date as its attached Pax + Rust definitions.","1-run-the-parser-binary#1. Run the parser binary":"After generating the parse_to_manifest logic during the compilation of the parser binary (above,) the Pax compiler calls the resulting executable, which gathers all the parsed information of a Pax program, packs that data into a PaxManifest, then serializes and passes that manifest back to the Pax compiler.This PaxManifest represents the entire definition of the program, in a simple data structure.  Once the PaxManifest is populated, the parsing work is done.","2-codegen#2. Codegen":"From the PaxManifest obtained by parsing, Pax generates \"Rust Intermediate Language\", i.e. just plain Rust in a specific configuration for the purposes of the Pax runtimes.  Some components of RIL:\nThe PropertiesCoproduct — data structure representing the disjoint union of all component property types, used by runtime to enable polymorphic management of Components and their Properties,\nThe TypesCoproduct — data strucure representing the disjoint union of all Property types, used by the runtime to enable polymorphic management of expression vtable entries, expression parameters, and expression return types\nThe cartridge definition — two major components:\na vtable containing every compiled Expression and\ninstance factories for components & primitives, invoked recursively underneath get_main_component_instance","3-chassis-compilation#3. Chassis Compilation":"Recall the \"inversion of dependencies\" described earlier in this chapter.  The final executable for a given platform is the whole \"NES Console\", but we have only been building the \"Cartridge\" thus far.Now it's time to put the cartridge into the console — which means we must involve a different compiler.  For example, to build for macOS, xcode is invoked to build the Swift + C dev harness which embeds the macOS chassis, which in turn embeds the dynamic cartridge built by Pax.The dev harness is a nearly empty macOS app, built in Swift and Xcode, intended for developing Pax.  The harness + the chassis is collectively our metaphorical console.  Not yet built at the time of this authoring is a production harness, which is a separate macOS app (or configuration of the same macOS app) tuned for production builds.To pass the compiled, code-genned cartridge into this compilation chain, the Pax compiler uses the Cargo patch directive.  This swaps the \"placeholder\" definitions, the basic stubs included on GitHub for pax-cartridge and pax-properties-coproduct, for example, out for the new, freshly generated cartridge content.Now, when compiled through Xcode (for our macOS example,) we have a complete, native executable.","4-run-or-finish#4. Run or Finish":"Depending on whether you tasked the compiler with run or build, the compiler will either run the resulting executable immediately, or write the executable to disk in the specified directory"}},"/reference/designability":{"title":"Designability","data":{"":"Pax is designed with a very specific goal in mind.  In fact, Pax wouldn't exist if there were existing compelling solutions that already achieved this goal.That goal is designability.  What does that mean?Simply put, Pax code should be readable and writable by a machine as well as readable and writable by a human.  Instead of one-way \"codegen\" paradigms, Pax is designed to go two ways: from code to design, and from design back to code.","how-does-this-work#How does this work?":"","pax-is-just-data#Pax is just data":"Pax's templates, settings, and even expressions are just data.  In fact, expressions are the crux of enabling this designability.Recall that an expression can be written anywhere you set a property.  Such expressions are constrained to be \"Excel-formula-like\" — in more precise words, each expression is a pure function of some tuple of state.This means no side effects, no sequencing of operations — essentially, none of the hairy stuff that might break a computer's expectation of reading & writing back to, for example: React JSX templates, SwiftUI views, or Flutter widgets.Pax's entire format, including Expressions, can be losslessly and deterministically loaded into and back out of a relational data store like a RDBMS: the same kind of data store used by any modern vector design tool.","pax-renders-in-design-tool-coordinates#Pax renders in design tool coordinates":"This chapter goes into more detail, but in short: Pax elements are positioned like you would expect them to be positioned in a vector design tool.  The most notable addition is Pax's notion of align, which allows you to create responsive positioning and layouts, still in a design-friendly way. (c.f. autolayout in Figma.)","pax-can-encode-any-design-file-and-any-ui#Pax can encode any design file, and any UI":"Pax is intended to be a suitable language for encoding design data, like the contents of a Figma file or an Illustrator file.  Additionally, Pax is intended to be a suitable language for encoding GUI or interactive graphical scene definitions — like an old Flash source file, a Visual Basic screen, or a modern Web GUI.","faq#FAQ":"","shouldnt-design-live-in-a-separate-world-vs-code#Shouldn't design live in a separate world vs. code?":"Many people believe this way.  Many others do not.  In the end, Pax will support either paradigm:  you can choose to create pictures or prototypes with Pax-enabled design tools, or you can build & ship production apps by collaborating through version control.  It all depends on your team, your tech stack, and your workflow.","isnt-code-gen-bad-or-limited#Isn't code-gen bad? Or limited?":"Yes.  Consider the traditional code-generating design tool: most prior art in this space has found workflow limitions due to the \"ejecting\" nature of codegen.When you generate code from a traditional design tool, you embark on a one-way bridge — the moment that code is edited by hand, e.g. by a developer who's responsible for shipping it at the end of the day — that code irrevocably breaks away from the design tool, disallowing further collaboration.Pax enables a two-way bridge through language-level constraints — there's no way to \"break away\" because Pax will always be re-parsable by a Pax-enabled design tool, even after it's edited by hand.One piece of mainstream prior art that achieved this \"two-way\" bridge was Macromedia Dreamweaver (now Adobe Dreamweaver.)  Dreamweaver's primary challenge to visual designers was that it inherited the Web's document layout model, instead of \"design tool coordinates\" — so simple tasks like drawing a box or vertically centering an element were arcane and very \"un-design-tool-like.\"   Pax addresses exactly this concern with its design tool coordinates for rendering.","pax-programs-include-rust--how-is-that-designable#Pax programs include Rust.  How is that designable?":"In short: separation of concerns.  Recall that Pax describes the content and behavior of a UI.  Incidentally, that's exactly what a design tool does.When Pax is designed by a Pax-enabled design tool, the attached Rust logic can be either evaluated or ignored while designing, depending on the context.  Separately, you can pop open a code editor and edit that Rust code.Rust code (and future other supported languages, like JavaScript) are not intended to be designed with Pax; they're intended to be coded.  If you ever authored a program in Flash, you will find this model familiar.Pax's major departure from Flash's design+code model is Pax's addition of expressions, which are intended to be authored by coding them into a design tool — anywhere you might enter a literal value into a text box in a design tool, e.g. to write a hex color by hand, or set the width of a vector rectangle, you can alternatively write an expression. Think: spreadsheet formula."}},"/reference/hardware-component-model":{"title":"Hardware Component Model","data":{"":"Components in Pax are inspired by components on a digital circuit board — namely: they are signal-driven, encapsulated, and composable.Though you wouldn't want to describe an actual circuit with Pax, we can illustrate this parallel with a virtual AndGateLED and two signal inputs (Property<T>), outputting to a VirtualLED component that lights up when the inputs are both true.\n//and_gate.rs\n#[pax(\n    <VirtualLED signal={self.input_a && self.input_b} >\n)]\npub struct AndGateLED {\n    input_a: Property<bool>,\n    input_b: Property<bool>,\n}\nThis AndGateLED might be used in some other component's template like:\n<AndGateLED input_a={self.is_validated} input_b={self.is_accepted_by_server} />\nWhile contrived, this example may look vaguely familiar if you've used a visual circuit design tool for FPGAs with VHDL or Verilog.  Here's a screenshot from such a tool[1], illustrating how circuit components expose both inputs and outputs, and compose with each other for logic flow.Looking at Pax through this lens, properties are component \"inputs\", while settings are component \"outputs\".  The hierarchy of components is declared through the template of each component, traversed as a single combined tree by the Pax compiler & runtime.  You can read more in the chapters Properties & Settings, Expressions, and Templates[1] Image credit: Aldec, Inc. https://www.aldec.com/en/products/fpga_simulation/designeredition"}},"/reference/native-rendering":{"title":"Native Rendering","data":{"":"To render both native UI elements and native 2D drawing, every running Pax program renders to two separate layers, through different rendering contexts, composited with a unified coordinate space, clipping context, and event handling mechanism.","native-overlay#Native Overlay":"The top layer is the native overlay — simply, a layer of OS-native elements, like SwiftUI Text or Slider elements on macOS/iOS, and <span> or <button /> in browsers.Each native element is transformed and clipped in order to fit into the broader rendering context.  For example, if a Button is expected to be at the center of the screen, the Pax runtime knows how to transform, size, and clip that native element, to make it \"float\" in exactly the right place.","canvas-underlay#Canvas Underlay":"Underneath the native layer is a separate layer, where drawing operations occur.Any of the drawing primitives like Rectangle, Ellipse, and Path draw to this layer.  In the future, certain effects like drop shadows may draw to this layer as well.","message-passing-via-ffi-c-structs#Message-passing via FFI, C Structs":"Drawing to the canvas is straight-forward:  for a given operating system, Pax receives a pointer to a native canvas, as uses a polyfill (provided by the open source library Piet) to turn a drawing operation like BezPath into a operating-system native drawing call.The result of this is that canvas drawing happens natively — for example, via CoreGraphics on macOS and iOS, Canvas2D in the browser, and Direct2D on Windows.How does Pax know how to draw native UI elements like Text?This is done through message-passing.  The Pax engine knows any time a native element is created, has its properties updated, or is deleted (removed from render tree, e.g. via if.)  When any of these \"CRUD\" operations occur, the runtime sends a message to the chassis, and the chassis is responsible for interpreting that message and drawing the native elements that result.The messages are sent a C structs via a low-level bridge, using Rust's FFI functionality.  Serialization depends on the platform — for example, messages are passed as FlatBuffers on macOS but JSON in the browser (to avoid bloating .wasm footprint with a deserialization dependency.)","clipping--occlusion#Clipping & Occlusion":"When an element is clipped, for example by placing it into a Frame element, each of the native overlay and canvas underlay layers are responsible for doing their own clipping, by separate mechanisms.The native layer clips using an OS-specific clipping mechanism, for example .clipped() on macOS and clip-path on Web.The canvas layer also uses an OS-specific clipping mechanism, but at the GPU/drawing level.Occlusion works by stacking native and canvas layers in the chassis. Based on the render tree's understanding of z-index, we create additional native & canvas layers to simulate occlusion.","accessibility--seo#Accessibility & SEO":"A lovely emergent property of using native elements for content like text, is that operating-system level accessibility measures (like screen readers) just work out of the box.For example, if you right-click + inspect a text element in Pax Web, you'll see that it is rendered into the DOM as a <span>Your text here</span>, as opposed to rasterized in a canvas.  Screen readers read this content natively.SEO, or search engine optimization a.k.a. Google / DuckDuckGo compatibility, is also thus solved, allowing crawlers to access text content exactly as they would in any plain ol' Web page or application.","footprint#Footprint":"Worth noting about this approach is that it significantly reduces the footprint burden of the Pax runtime.  This hybrid native-canvas/native-elements approach allows Pax to render without needing to bundle a fully featured rendering engine like Skia, which would add megabytes to base footprints.For reference, this footprint burden is one of the challenges faced by many cross-platform renderers like Flutter — commonly, such tools require bundling Skia and downloading megabytes of data in order to load a single page in a browser.Pax aims to keep its base footprint <100kB."}},"/reference/paxel":{"title":"PAXEL","data":{"":"PAXEL is Pax's expression language.","the-language#The Language":"PAXEL is very similar to at least two existing languages: Microsoft's Excel spreadsheet formula language, and Google's Common Expression Language (CEL). PAXEL shares the following characteristics with CEL[1]:\nmemory-safe: programs cannot access unrelated memory, such as out-of-bounds array indexes or use-after-free pointer dereferences;side-effect-free: a PAXEL program only computes an output from its inputs;terminating: PAXEL programs cannot loop forever;strongly-typed: values have a well-defined type, and operators and functions check that their arguments have the expected types;type-inferred: while explicit type declarations are not required in PAXEL, a type-checking phase occurs before runtime via rustc, which detects and rejects programs that would violate type constraints.\nWhy not CEL? Because PAXEL and CEL are so alike, it was tempting to use CEL rather than create a new language.  However:  PAXEL has a tighter, more specialized scope than CEL and carries a much smaller runtime footprint — namely because CEL is written in Go, which requires embedding Go's runtime and garbage collector, adding megabytes to every WASM / binary file.  Further, having complete control of the memory underlying the expression runtime enables the scoping & integration functionality between Pax Properties and Pax Expressions, and the Rust-based machine-code-compiled Expression vtable fits nicely within Pax's \"cartridge\" model.","paxel-grammar#PAXEL Grammar":"See the source code.","paxel-compilation#PAXEL Compilation":"PAXEL is compiled by transpiling through Rust.  In practice, this is fairly straight-forward — in many cases, PAXEL and Rust are syntactically identical.PAXEL's scoping mechanism requires special consideration by Pax's compiler — for example, inside a template for loop, PAXEL can refer to the scoped predicate declaration (e.g. the i in for i in 0..10).\n//template:\n<Group>\n    for i in 0..10 {\n        //notice that PAXEL can refer to the `i` from the for loop.  This works when nesting `for` loops, too.\n        <Rectangle transform={Translate2D::translate(i * 100.0, i * 100.0)} /> \n    }\n</Group>\nPAXEL can also refer to symbols available on the attached Rust struct, through self.some_symbol, and can refer to certain cartridge \"prelude imports\", a compiler-hard-encoded list of symbols that are imported and available to all Expressions, such as Transform2D::* and Color::* (which is where translate(), scale(), rgba(), etc. are defined.) .PAXEL shadows scopes, allowing stacking of scope contexts and overriding previously scoped symbols with newer/more specific references — for example, when nesting for loops.Finally, PAXEL can refer to the symbol representing the type of the Property associated with an expression — for example an expression bound to some_complex_property: Property<SomeComplexType> can use SomeComplexType:\n#some_id {\n    some_complex_property: {\n        // The following returns a new instance of SomeComplexType.\n        // The symbol `SomeComplexType` may be used here because the Pax compiler + runtime knows\n        // that `some_complex_property`'s type is `Property<SomeComplexType>`.\n        SomeComplexType {\n            a: self.num_clicks + 5,\n            b: self.active_width,\n            c: \"Hello\"\n        }\n    }\n}\nWith a reasonable and finite amount of work, PAXEL will also be able to refer to \"anything within scope\" within a Rust file, allowing the import & use of arbitrary symbols & packages.  This approach will build on the get_type_id work done by the parser to reflect on Property types.  Until that time, using an arbitrary import — for example, calling an imported method — requires re-exposing that method through a method available on self.[1] Text modified from source: https://github.com/google/cel-spec/blob/master/doc/langdef.md"}}}